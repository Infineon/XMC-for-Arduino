/**
 * @file xmc_common.h
 *
 * @cond
 *****************************************************************************
 * XMClib - XMC Peripheral Driver Library
 *
 * Copyright (c) 2015-2023, Infineon Technologies AG
 * All rights reserved.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * To improve the quality of the software, users are encouraged to share
 * modifications, enhancements or bug fixes with Infineon Technologies AG
 * at XMCSupport@infineon.com.
 *****************************************************************************
 *
 * @endcond
 */

#ifndef XMC_COMMON_H
#define XMC_COMMON_H

#include <stddef.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <string.h>

#include "xmc_device.h"


/**
 * @addtogroup COMMON
 * @brief Common APIs to all peripherals for XMC microcontroller family
 
 * The Common driver contains a set of different system functions. These functions
 * can be called in the application routine.
 * @{
 */

/**********************************************************************************************************************
 * MACROS
 *********************************************************************************************************************/
#define XMC_LIB_MAJOR_VERSION	(4U)
#define XMC_LIB_MINOR_VERSION	(3U)
#define XMC_LIB_PATCH_VERSION	(0U)

#define XMC_LIB_VERSION         ((XMC_LIB_MAJOR_VERSION << 16U) + (XMC_LIB_MINOR_VERSION << 8U) + XMC_LIB_PATCH_VERSION)

#define XMC_VERSION_NUMBER(major, minor, patch)         ((major << 16U) + (minor << 8U) + patch)

/* Define WEAK attribute */
#if !defined(__WEAK)
#if defined ( __CC_ARM )
#define __WEAK __attribute__ ((weak))
#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
#define __WEAK __attribute__ ((weak))
#elif defined ( __ICCARM__ )
#define __WEAK __weak
#elif defined ( __GNUC__ )
#define __WEAK __attribute__ ((weak))
#elif defined ( __TASKING__ )
#define __WEAK __attribute__ ((weak))
#endif
#endif

#if !defined(__RAM_FUNC)
#if defined ( __CC_ARM )
// http://www.keil.com/support/docs/3723.htm
#define __RAM_FUNC __attribute__((section("RAMCODESECTION")))
#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
#define __RAM_FUNC __attribute__((section("RAMCODESECTION")))
#elif defined ( __ICCARM__ )
// https://www.iar.com/support/tech-notes/linker/controlling-placement-of-the-section-where-__ramfunc-functions-reside-ewarm-5.x--6.x/
#define __RAM_FUNC __ramfunc
#elif defined ( __GNUC__ )
#define __RAM_FUNC __attribute__((section(".ram_code"), long_call))
#elif defined ( __TASKING__ )
#define __RAM_FUNC __attribute__((section(".ram_code")))
#endif
#endif

#ifdef XMC_ASSERT_ENABLE
#define XMC_ASSERT(msg, exp) { if(!(exp)) {XMC_AssertHandler(msg, __FILE__, __LINE__);} }
#else
#define XMC_ASSERT(msg, exp)
#endif

#ifdef XMC_DEBUG_ENABLE
#include <stdio.h>
#define XMC_DEBUG(...) { printf(__VA_ARGS__); }
#else
#define XMC_DEBUG(...)
#endif

#define XMC_UNUSED_ARG(x) (void)x

#define XMC_STRUCT_INIT(m) memset(&m, 0, sizeof(m))

/***************************************************************************************************
 * Macro Name: XMC_DIV_ROUND
 ***********************************************************************************************//**
 *
 *  Calculates a / b with rounding to the nearest integer,
 *  a and b must have the same sign.
 *
 **************************************************************************************************/
#define XMC_DIV_ROUND(a, b) (((a) + ((b) / 2U)) / (b))

/***************************************************************************************************
 * Macro Name: XMC_DIV_ROUNDUP
 ***********************************************************************************************//**
 *
 *  Calculates a / b with rounding up if remainder != 0,
 *  both a and b must be positive.
 *
 **************************************************************************************************/
#define XMC_DIV_ROUNDUP(a, b) ((((a) - 1U) / (b)) + 1U)

/** @cond */
/**********************************************************************************************************************
 * DATA STRUCTURES
 *********************************************************************************************************************/
/*
 *
 */
typedef struct XMC_DRIVER_VERSION
{
  uint8_t major;
  uint8_t minor;
  uint8_t patch;
} XMC_DRIVER_VERSION_t;
/** @endcond */

/**********************************************************************************************************************
 * API PROTOTYPES
 *********************************************************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 *
 */
void XMC_AssertHandler(const char *const msg, const char *const file, uint32_t line);

/*******************************************************************************
* Function Name: XMC_DelayCycles
****************************************************************************//**
*
* The function delays by the specified number of CPU clock cycles.
*
* \note There is memory reading timing limitation in XMC1xxx device family
*       (see section Memory Read in the device TRM)
*       this may significantly stretch this function execution,
*       especially at high CPU speeds.
*
* @param cycles The number of CPU clock cycles to delay.
*               Valid range: 0x0 .. 0xFFFFFFFD.
*
*******************************************************************************/
void XMC_DelayCycles(uint32_t cycles);

/*******************************************************************************
* Function Name: XMC_Delay
****************************************************************************//**
*
* The function delays by the specified number of milliseconds.
* The number of cycles to delay is calculated based on the
* \ref SystemCoreClock.
*
* @param milliseconds  The number of milliseconds to delay.
*
* \note The function calls \ref XMC_DelayCycles() API to generate a delay.
*       If the desired delay is bigger than 0xFFFFFFFD CPU cycles,
*       then an additional loop runs to prevent
*       an overflow in parameter passed to \ref XMC_DelayCycles() API.
*
*******************************************************************************/
void XMC_Delay(uint32_t milliseconds);

/*******************************************************************************
* Function Name: XMC_DelayUs
****************************************************************************//**
*
* The function delays by the specified number of microseconds.
* The number of cycles to delay is calculated based on the
* \ref SystemCoreClock.
*
* @param microseconds  The number of microseconds to delay.
*
* \note If the CPU frequency in MHz is a small number,
*       the actual delay can be significantly bigger than the desired value.
*       The actual delay cannot be shorter than the desired one.
*
*******************************************************************************/
void XMC_DelayUs(uint16_t microseconds);

/*******************************************************************************
* Function Name: XMC_EnterCriticalSection
****************************************************************************//**
*
*  XMC_EnterCriticalSection disables interrupts and returns a value
*  indicating whether the interrupts were previously enabled.
*
*  \return Returns the current interrupt status. Returns 0 if the interrupts
*          were previously enabled or 1 if the interrupts were previously
*          disabled.
*
*  \note Implementation of XMC_EnterCriticalSection manipulates the IRQ
*        enable bit with interrupts still enabled.
*
*******************************************************************************/
uint32_t XMC_EnterCriticalSection(void);

/*******************************************************************************
* Function Name: XMC_ExitCriticalSection
****************************************************************************//**
*
*  Re-enables the interrupts if they were enabled before
*  XMC_EnterCriticalSection() was called. The argument should be the value
*  returned from \ref XMC_EnterCriticalSection().
*
*  \param savedIntrStatus  Puts the saved interrupts status returned by
*         the \ref XMC_EnterCriticalSection().
*
*******************************************************************************/
void XMC_ExitCriticalSection(uint32_t savedIntrStatus);

#ifdef __cplusplus
}
#endif

/**
 * @} (end addtogroup COMMON)
 */

#endif /* XMC_COMMON_H */
